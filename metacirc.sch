(define (eval exp env)
	(cond ((self-evaluating? exp) exp)
		((variable? exp) (lookup-variable-value exp env))
		((quoted? exp) (text-of-quotation exp))
		((assignment? exp) (eval-assignment exp env))
		((definition? exp) (eval-definition exp env))
		((if? exp) (eval-if exp env))
		((and? exp) (eval-and exp env))
		((or? exp) (eval-or exp env))
		((lambda? exp)
			(make-procedure (lambda-parameters exp)
			(lambda-body exp) env)
		)
		((begin? exp) 
			(eval-sequence (begin-actions exp) env))
		((cond? exp) (eval (cond->if exp) env))
		((let? exp) (eval (let->combination exp) env))
		((let*? exp)
			(eval (let*->nested-lets exp) env)
		)
		((letrec? exp) (eval (letrec->let exp) env))
		((application? exp)
			(apply (eval (operator exp) env)
				(list-of-values (operands exp) env)))
		(else (error "Unknown expression type -- EVAL" exp))
	)
)
(define apply-in-underlying-scheme apply)
(define (apply procedure arguments)
	(cond
		((primitive-procedure? procedure)
			(apply-primitive-procedure procedure arguments)
		)
		((compound-procedure? procedure)
			(eval-sequence
				(procedure-body procedure)
				(extend-environment (procedure-parameters procedure) arguments (procedure-environment procedure)))
		)
		(else (error "Unknown procedure type -- APPLY" procedure))
	)
)
(define (list-of-values exps env)
	(if (no-operands? exps)
		'()
		(cons (eval (first-operand exps) env) (list-of-values (rest-operands exps) env))
	)
)
(define (eval-if exp env)
	(if (true? (eval (if-predicate exp) env))
		(eval (if-consequent exp) env)
		(eval (if-alternative exp) env)
	)
)
(define (and? exp) (tagged-list? exp 'and))
(define (or? exp) (tagged-list? exp 'or))
(define (eval-and exp env)
	(define (iter exps)
		(cond
			((null? exps) true)
			((null? (cdr exps)) (eval (car exps) env))
			((not (eval (car exps) env)) false)
			(else (iter (cdr exps)))
		)
	)
	(iter (cdr exp))
)
(define (eval-or exp env)
	(define (iter exps)
		(cond
			((null? exps) false)
			((null? (cdr exps)) (eval (car exps) env))
			((eval (car exps) env) true)
			(else (iter (cdr exps)))
		)
	)
	(iter (cdr exp))
)
(define (eval-sequence exps env)
	(cond
		((last-exp? exps) (eval (first-exp exps) env))
		(else
			(eval (first-exp exps) env)
			(eval-sequence (rest-exps exps) env)
		)
	)
)
(define (eval-assignment exp env)
	(set-variable-value! (assignment-variable exp) (eval (assignment-value exp) env) env)
	'ok
)
(define (eval-definition exp env)
	(define-variable! (definition-variable exp) (eval (definition-value exp) env) env)
	'ok
)
(define (self-evaluating? exp)
	(cond
		((number? exp) true)
		((string? exp) true)
		((null? exp) true)
		(else false)
	)
)
(define (tagged-list? exp tag)
	(if (pair? exp)
		(eq? (car exp) tag)
		false
	)
)
(define (variable? exp) (symbol? exp))
; (quote text)
(define (quoted? exp) (tagged-list? exp 'quote))
(define (text-of-quotation exp) (cadr exp))
; (set! var val)
(define (make-assignment var val) (list 'set! var val))
(define (assignment? exp) (tagged-list? exp 'set!))
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))
; (define var value)
; (define (var p1 p2) body) -> (define var (lambda (p1 p2) body))
(define (definition? exp) (tagged-list? exp 'define))
(define (definition-variable exp)
	(if (pair? (cadr exp))
		(caadr exp)
		(cadr exp)
	)
)
(define (definition-value exp)
	(if (pair? (cadr exp))
		(make-lambda
			(cdadr exp) ; parameters
			(cddr exp) ; body
		)
		(caddr exp)
	)
)
; (lambda (x y z) body)
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))
(define (make-lambda parameters body)
	(cons 'lambda (cons parameters body))
)
; (if pred conseq alt)
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
	(if (null? (cdddr exp))
		false
		(cadddr exp)
	)
)
(define (make-if pred conseq alt)
	(list 'if pred conseq alt)
)
; (begin exp1 exp2)
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (first-exp seq) (car seq))
(define (last-exp? seq) (null? (cdr seq)))
(define (rest-exps seq) (cdr seq))
(define (make-begin seq) (cons 'begin seq))
(define (sequence->exp seq)
	(cond
		((null? seq) seq)
		((last-exp? seq) (first-exp seq))
		(else (make-begin seq))
	)
)
; procedure
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))
; cond
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-predicate clause) (car clause))
(define (cond-else-clause? clause) (eq? (cond-predicate clause) 'else))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp)
	(expand-clauses (cond-clauses exp))
)
(define (cond-test-clause? clause) (eq? (cadr clause) '=>) )
(define (cond-test-proc clause) (caddr clause))
(define (cond-test-arg clause) (cons-predicate clause))
(define (expand-clauses clauses)
	(if (null? clauses)
		'false						  ; no else clause
		(let ((first (car clauses)) (rest (cdr clauses)))
			(cond
				((cond-else-clause? first)
					(if (null? rest)
						(sequence->exp (cond-actions first))
						(error "ELSE clause isn't last -- COND->IF" clauses)
					)
				)
				((cond-test-clause? first)
					(make-if (cond-predicate first)
						(list (cond-test-proc first) (cond-test-arg clause))
						(expand-clauses rest)
					)
				)
				(else
					(make-if (cond-predicate first)
						(sequence->exp (cond-actions first))
						(expand-clauses rest)
					)
				)
			)
		)
	)
)
; let
(define (let? exp) (tagged-list? exp 'let))
(define (let-keyval exp) (if (named-let? exp) (caddr exp) (cadr exp)))
(define (let-body exp) (if (named-let? exp) (cadddr exp) (caddr exp)))
(define (make-let keyval body) (list 'let keyval body))
(define (let->combination exp)
	(if (named-let? exp)
		(make-begin
			(list 
				(list 'define (cons (named-let-name exp) (map car (let-keyval exp))) (let-body exp) )
				(cons (named-let-name exp) (map cadr (let-keyval exp)))
			)
		)
		(cons (make-lambda (map car (let-keyval exp)) (list (let-body exp))) (map cadr (let-keyval exp)) )
	)
)
(define (let*? exp) (tagged-list? exp 'let*))
(define (let*->nested-lets exp)
	(if (null? (let-keyval exp))
		(let-body exp)
		(let->combination 
			(make-let
				(list (car (let-keyval exp))) 
				(let*->nested-lets (make-let (cdr (let-keyval exp)) (let-body exp)))
			)
		)
	)
)
(define (named-let? exp) (and (let? exp) (not (list? (cadr exp)))))
(define (named-let-name exp) (cadr exp))
(define (append elem lst)
	(if (null? lst)
		(cons elem '())
		(cons (car lst) (append elem (cdr lst)))
	)
)
(define (named-let->let exp)
	(make-let
		(append (list (named-let-name exp) (make-lambda (map car (let-keyval exp)) (list (let-body exp)))) (let-keyval exp))
		(let-body exp)
	)
)
; predicates
(define (true? x) (not (eq? x false)))
(define (false? x) (eq? x false))
; compound procedures
(define (make-procedure parameters body env) (list 'procedure parameters body env))
(define (compound-procedure? p) (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))
; operations on environments
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())
(define (make-frame variables values)
	(cons variables values)
)
(define (frame-variables frame) (car frame))
(define (frame-values frame) (cdr frame))
(define (add-binding-to-frame! var val frame)
	(set-car! frame (cons var (car frame)))
	(set-cdr! frame (cons val (cdr frame)))
)
(define (extend-environment vars vals base-env)
	(if (= (length vars) (length vals))
		(cons (make-frame vars vals) base-env)
		(if (> (length vars) (length vals))
			(error "More variables than values")
			(error "More values than variables")
		)
	)
)
(define (lookup-variable-value var env)
	(define (scan vars vals)
		(cond
			((null? vars) (lookup-variable-value var (enclosing-environment env)))
			((eq? var "*unassigned*") (error "Unassigned value found."))
			((eq? var (car vars)) (car vals))
			(else (scan (cdr vars) (cdr vals)))
		)
	)
	(if (eq? env the-empty-environment)
		(error "Unbound variable LOOKUP" var)
		(let ((frame (first-frame env)))
			(scan (frame-variables frame) (frame-values frame))
		)
	)
)
(define (define-variable! var val env)
	(let ((frame (first-frame env)))
		(define (scan vars vals)
			(cond
				((null? vars) (add-binding-to-frame! var val frame))
				((eq? var (car vars)) (set-car! vals val))
				(else (scan (cdr vars) (cdr vals)))
			)
		)
		(scan (frame-variables frame) (frame-values frame))
	)
)
(define (set-variable-value! var val env)
	(define (env-loop env)
		(define (scan vars vals)
			(cond
				((null? vars) (set-variable-value! var val (enclosing-environment env)))
				((eq? var (car vars)) (set-car! vals val))
				(else (scan (cdr vars) (cdr vals)))
			)
		)
		(if (eq? env the-empty-environment)
			(error "Unbound variable SET-VARIABLE")
			(let ((frame (first-frame env)))
				(scan (frame-variables frame) (frame-values frame))
			)
		)
	)
	(env-loop env)
)
(define (make-unbound! var env)
	(define (env-loop env)
		(define (scan vars vals)
			(begin
				(set! vars (filter (lambda (v) (not (eq? var (car v)))) vars))
				(set! vals (filter (lambda (v) (not (eq? var (car v)))) vals))
				(make-unbound! var (enclosing-environment env))
			)
		)
		(if (not (eq? env the-empty-environment))
			(let ((frame (first-frame env)))
				(scan (frame-variables frame) (frame-values frame))
			)
		)
	)
	(env-loop env)
)
; setup global environment
(define primitive-procedures
	(list
		(list 'car car)
		(list 'cdr cdr)
		(list 'cons cons)
		(list 'null? null?)
		(list '+ +)
		(list '- -)
		(list '= =)
		(list '* *)
		(list '/ /)
		(list 'map map)
		(list 'display display)
		(list 'newline newline)
		(list 'list list)
	)
)
(define (primitive-procedure-names) (map car primitive-procedures))
(define (primitive-procedure-objects) (map (lambda (proc) (list 'primitive (cadr proc))) primitive-procedures))
(define (apply-primitive-procedure proc args) (apply-in-underlying-scheme (primitive-implementation proc) args))
(define (setup-environment)
	(let ((initial-env 
		(extend-environment (primitive-procedure-names) (primitive-procedure-objects) the-empty-environment)
		))
		(define-variable! 'true true initial-env)
		(define-variable! 'false false initial-env)
		initial-env
	)
)
(define the-global-environment (setup-environment))
; primitive procedures
(define (primitive-procedure? proc) (tagged-list? proc 'primitive))
(define (primitive-implementation proc) (cadr proc))
; REPL
(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval output:")
(define (driver-loop) 
	(prompt-for-input input-prompt)
	(let ((input (read)))
		(let ((output (eval input the-global-environment)))
			(announce-output output-prompt)
			(user-print output)
		)
	)
	(driver-loop)
)
(define (prompt-for-input string)
	(newline) (newline) (display string) (newline)
)
(define (announce-output string)
	(newline) (display string) (newline)
)
(define (user-print object)
	(if (compound-procedure? object)
		(display (list 'compound-procedure (procedure-parameters object) (procedure-body object) '<procedure-env>))
		(display object)
	)
)

(define (last-item lst)
	(if (null? (cdr lst))
		lst
		(last-item (cdr lst))
	)
)

; ex 4.16
(define (scan-out-defines body)
	(define (iter body letvars letbody)
		(cond
			((null? (cdr body)) 
				(if (null? letbody)
					body
					(begin
						(set-cdr! (last-item letbody) body)
						(list (make-let letvars (make-begin letbody)))
					)
				)
			)
			((definition? (car body)) 
				(let* ( (bdy (car body)) (var (definition-variable bdy)) (val (definition-value bdy)) )
					(iter
						(cdr body)
						(cons (list var (quote '*unassigned*)) letvars)
						(cons (make-assignment var val) letbody))
				)
			)
			(else (iter (cdr body) letvars letbody))
		)
	)
	(iter body '() '())
)

(define (make-procedure parameters body env) (list 'procedure parameters (scan-out-defines body) env))

; ex 4.18

;(define (solve f y0 dt)
;	(define y (integral (delay dy) y0 dt))
;	(define dy (stream-map f y))
;	y
;)

; Both variants don't work

;(define (solve f y0 dt)
;	(let ((y '*unassigned*) (dy '*unassigned*))
;		(let ((*y (integral (delay dy) y0 dt)) (*dy (stream-map f y)))
;			(set! y *y)
;			(set! dy *dy)
;			y
;		)
;	)
;)
;(define (solve f y0 dt)
;	(let ((y '*unassigned*) (dy '*unassigned*))
;		(set! y (integral (delay dy) y0 dt))
;		(set! dy (stream-map f y))
;		y
;	)
;)

; ex 4.19
;(let ((a 1))
;	(define (f x)
;		(define b (+ a x))
;		(define a 5)
;		(+ a b)
;	)
;	(f 10)
;)

;(let ((a 1))
;	(let
;		((f '*unassigned*))
;		(set! f 
;			(lambda (x) 
;				(let ((b '*unassigned*) (a '*unassigned*))
;					(set! b (+ a x))
;					(set! a 5)
;					(+ a b)
;				)
;			)
;		)
;		(f 10)
;	)
;)

; ex 4.20
(define (letrec? exp) (tagged-list? exp 'letrec))
(define (letrec->let exp)
	(let ((keyval (let-keyval exp)) (body (let-body exp)))
		(define (iter kv letvars letbody)
			(cond
				((null? kv)
					(make-let letvars (make-begin letbody))
				)
				(else
					(let ( (k (caar kv)) (v (cdar kv)) )
						(iter
							(cdr kv)
							(cons (list k (quote '*unassigned*)) letvars)
							(cons (cons 'set! (car kv)) letbody))
					)
				)
			)
		)
		(iter keyval '() (list body))
	)
)

(define (f x)
  (letrec ((even?
            (lambda (n)
              (if (= n 0)
                  true
                  (odd? (- n 1)))))
           (odd?
            (lambda (n)
              (if (= n 0)
                  false
                  (even? (- n 1))))))
    (even? x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(define (eval exp env) ((analyze exp) env))
(define (analyze exp)
	(cond
		((self-evaluating? exp) (analyze-self-evaluating exp))
		((quoted? exp) (analyze-quoted exp))
		((variable? exp) (analyze-variable exp))
		((assignment? exp) (analyze-assignment exp))
		((definition? exp) (analyze-definition exp))
		((if? exp) (analyze-if exp))
		((lambda? exp) (analyze-lambda exp))
		((begin? exp) (analyze-sequence exp))
		((cond? exp) (analyze-cond exp))
		((let? exp) (analyze-let exp))
		((application? exp) (analyze-application exp))
		(else
			(error "Unknown expression type ANALYZE" exp)
		)
	)
)

(define (analyze-self-evaluating exp) (lambda (env) exp))
(define (analyze-quoted exp)
	(let ((qval (text-of-quotation exp)))
		(lambda (env) qval)
	)
)
(define (analyze-variable exp) (lambda (env) (lookup-variable-value exp env)))
(define (analyze-assignment exp)
	(let ((var (assignment-variable exp)) (vproc (analyze (assignment-value exp))))
		(lambda (env)
			(set-variable-value! var (vproc env) env)
			'ok
		)
	)
)
(define (analyze-definition exp)
	(let ((var (definition-variable exp)) (vproc (analyze (definition-value exp))))
		(lambda (env)
			(define-variable! var (vproc env) env)
			'ok
		)
	)
)
(define (analyze-if exp)
	(let ((pproc (analyze (if-predicate exp))) (cproc (analyze (if-consequent exp))) (aproc (analyze (if-alternative exp))))
		(lambda (env)
			(if (true? (pproc env))
				(cproc env)
				(aproc env)
			)
		)
	)
)
;(define (make-procedure parameters body env) (list 'procedure parameters body env))
(define (analyze-lambda exp)
	(let ((param (lambda-parameters exp)) (bproc (analyze-sequence (lambda-body exp))))
		(lambda (env)
			(make-procedure param bproc env)
		)
	)
)
(define (analyze-sequence exps)
	(define (sequentially proc1 proc2)
		(lambda (env) (proc1 env) (proc2 env))
	)
	(define (loop first-proc rest-procs)
		(if (null? rest-procs)
			first-proc
			(loop (sequentially first-proc (car rest-procs)) (cdr rest-procs))
		)
	)
	(let ((procs (map analyze exps)))
		(display procs)
		(if (null? procs)
			(error "Empty sequence ANALYZE")
			(loop (car procs) (cdr procs))
		)
	)
)
(define (analyze-application exp)
	(let ((fproc (analyze (operator exp))) (aprocs (map analyze (operands exp))))
		(lambda (env)
			(execute-application (fproc env) (map (lambda (aproc) (aproc env)) aprocs))
		)
	)
)
(define (execute-application proc args)
	(cond
		((primitive-procedure? proc) (apply-primitive-procedure proc args))
		((compound-procedure? proc) 
			((procedure-body proc)
				(extend-environment (procedure-parameters proc) args (procedure-environment proc))
			)
		)
		(else (error "Unknown procedure type ANALYZE" proc args))
	)
)
; doesn't work on '(define (f x) (let ((even? (lambda (n) (if (= n 0) true (odd? (- n 1))))) (odd? (lambda (n) (if (= n 0) false (even? (- n 1)))))) (even? x)))
(define (analyze-let exp)
	(analyze (cons (make-lambda (map car (let-keyval exp)) (list (let-body exp))) (map cadr (let-keyval exp)) ))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 4.2

(define (eval exp env)
	(cond ((self-evaluating? exp) exp)
		((variable? exp) (lookup-variable-value exp env))
		((quoted? exp) (text-of-quotation exp))
		((assignment? exp) (eval-assignment exp env))
		((definition? exp) (eval-definition exp env))
		((if? exp) (eval-if exp env))
		((and? exp) (eval-and exp env))
		((or? exp) (eval-or exp env))
		((lambda? exp)
			(make-procedure (lambda-parameters exp)
			(lambda-body exp) env)
		)
		((begin? exp) 
			(eval-sequence (begin-actions exp) env))
		((cond? exp) (eval (cond->if exp) env))
		((let? exp) (eval (let->combination exp) env))
		((let*? exp)
			(eval (let*->nested-lets exp) env)
		)
		((letrec? exp) (eval (letrec->let exp) env))
		((application? exp)
			(apply (actual-value (operator exp) env)
				(operands exp) env))
		(else (error "Unknown expression type -- EVAL" exp))
	)
)
(define (actual-value exp env)
	(force-it (eval exp env))
)
(define (apply procedure arguments env)
	(cond
		((primitive-procedure? procedure)
			(apply-primitive-procedure procedure (list-of-arg-values arguments env))
		)
		((compound-procedure? procedure)
			(eval-sequence
				(procedure-body procedure)
				(extend-environment
					(procedure-parameters procedure)
					(list-of-delayed-args arguments env)
					(procedure-environment procedure)
				)
			)
		)
		(else (error "Unknown procedure type APPLY" procedure))
	)
)
;(define (list-of-arg-values arguments env)
;	(map (lambda (arg) (actual-value arg env)) arguments)
;)
(define (list-of-arg-values exps env)
	(if (no-operands? exps)
		'()
		(cons (actual-value (first-operand exps) env) (list-of-arg-values (rest-operands exps) env))
	)
)
(define (list-of-delayed-args exps env)
	(if (no-operands? exps)
		'()
		(cons (delay-it (first-operand exps) env) (list-of-delayed-args (rest-operands exps) env))
	)
)
(define (eval-if exp env)
	(if (true? (actual-value (if-predicate exp) env))
		(eval (if-consequent exp) env)
		(eval (if-alternative exp) env)
	)
)
(define input-prompt ";;; L-Eval input:")
(define output-prompt ";;; L-Eval output:")
(define (driver-loop)
	(prompt-for-input input-prompt)
	(let ((input (read)))
		(let ((output (actual-value input the-global-environment)))
			(announce-output output-prompt)
			(user-print output)
		)
	)
	(driver-loop)
)
(define (force-it obj)
	(if (thunk? obj)
		(actual-value (thunk-exp obj) (thunk-env obj))
		obj
	)
)
(define (delay-it exp env) (list 'thunk exp env))
(define (thunk? obj) (tagged-list? obj 'thunk))
(define (thunk-exp obj) (cadr obj))
(define (thunk-env obj) (caddr obj))
(define (evaluated-thunk? obj) (tagged-list? obj 'evaluated-thunk))
(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))
(define (force-it obj)
	(cond 
		((thunk? obj)
			(let ((result (actual-value (thunk-exp obj) (thunk-env obj))))
				(set-car! obj 'evaluated-thunk)
				(set-cdr! (cdr obj) '())
				(set-car! (cdr obj) result)
				result
			)
		)
		((evaluated-thunk? obj) (thunk-value obj))
		(else obj)
	)
)

; ex 4.31 works on simple procedures

(define (apply procedure arguments env)
	(cond
		((primitive-procedure? procedure)
			(apply-primitive-procedure procedure (list-of-arg-values arguments env))
		)
		((compound-procedure? procedure)
			(let ((params (procedure-parameters procedure)))
				(eval-sequence
					(procedure-body procedure)
					(extend-environment
						(strip-parameters params)
						(list-of-args params arguments env)
						(procedure-environment procedure)
					)
				)
			)
		)
		(else (error "Unknown procedure type APPLY" procedure))
	)
)
(define (strip-parameters params)
	(cond
		((null? params) '())
		((list? (car params)) (cons (caar params) (strip-parameters (cdr params))))
		(else (cons (car params) (strip-parameters (cdr params))))
	)
)
(define (delay-it-memo exp env) (list 'thunk-memo exp env))
(define (thunk-memo? obj) (tagged-list? obj 'thunk-memo))
(define (evaluated-thunk? obj) (tagged-list? obj 'evaluated-thunk))
(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))
(define (force-it obj)
	(cond 
		((thunk-memo? obj)
			(let ((result (actual-value (thunk-exp obj) (thunk-env obj))))
				(set-car! obj 'evaluated-thunk)
				(set-cdr! (cdr obj) '())
				(set-car! (cdr obj) result)
				result
			)
		)
		((thunk? obj) (actual-value (thunk-exp obj) (thunk-env obj)))
		((evaluated-thunk? obj) (thunk-value obj))
		(else obj)
	)
)
(define (list-of-args params exps env)
	(if (no-operands? exps)
		'()
		(let ((first (first-operand exps)) (rest (rest-operands exps)) (prm (car params)))
			(cond
				((not (list? prm)) (cons (actual-value first env) (list-of-args (cdr params) rest env)))
				((eq? (cadr prm) 'lazy) (cons (delay-it first env) (list-of-args (cdr params) rest env)))
				((eq? (cadr prm) 'lazy-memo) (cons (delay-it-memo first env) (list-of-args (cdr params) rest env)))
				(else (error "Unknown argument type LIST-OF-ARGS" first))
			)
		)
	)
)

; ex 4.33
; doesn't work :(
(define (quoted-list->cons lst)
	(if (null? lst)
		'()
		(list 'cons (car lst) (quoted-list->cons (cdr lst)))))
	)
)

(define (transform-quoted exp env)
	(let
		((txt (text-of-quotation exp)))
		(if (list? txt)
			(eval (quoted-list->cons txt) env)
			txt
		)
	)
)

(define (eval exp env)
	(cond ((self-evaluating? exp) exp)
		((variable? exp) (lookup-variable-value exp env))
		((quoted? exp) (transform-quoted exp env))
		;((quoted? exp) (text-of-quotation exp))
		((assignment? exp) (eval-assignment exp env))
		((definition? exp) (eval-definition exp env))
		((if? exp) (eval-if exp env))
		((and? exp) (eval-and exp env))
		((or? exp) (eval-or exp env))
		((lambda? exp)
			(make-procedure (lambda-parameters exp)
			(lambda-body exp) env)
		)
		((begin? exp) 
			(eval-sequence (begin-actions exp) env))
		((cond? exp) (eval (cond->if exp) env))
		((let? exp) (eval (let->combination exp) env))
		((let*? exp)
			(eval (let*->nested-lets exp) env)
		)
		((letrec? exp) (eval (letrec->let exp) env))
		((application? exp)
			(apply (actual-value (operator exp) env)
				(operands exp) env))
		(else (error "Unknown expression type -- EVAL" exp))
	)
)