;;;;;;;
; A register-machine simulator

(define (tagged-list? lst tag) (and (list? lst) (not (null? lst)) (eq? (car lst) tag)))

(define (make-machine register-names ops controller-text)
	(let	((machine (make-new-machine)))
		(for-each
			(lambda (register-name)
				((machine 'allocate-register) register-name)	
			) register-names
		)
		((machine 'install-operations) ops)
		((machine 'install-instruction-sequence) (assemble controller-text machine))
		machine
	)
)

(define (make-register name)
	(let ((contents '*unassigned*))
		(define (dispatch message)
			(cond 
				((eq? message 'get) contents)
				((eq? message 'set) (lambda (value) (set! contents value)))
				(else (error "Unknown request -- REGISTER" message))
			)
		)
		dispatch
	)
)
(define (make-stacked-register name)
	(let ((contents '*unassigned*) (stack (make-stack)))
		(define (dispatch message)
			(cond
				((eq? message 'get) contents)
				((eq? message 'set) (lambda (value) (set! contents value)))
				((eq? message 'stack) stack)
				(else (error "Unknown request -- REGISTER" message))
			)
		)
		dispatch
	)
)
(define (get-contents register) (register 'get))
(define (set-contents! register value) ((register 'set) value))

(define (make-stack)
	(let ((s '()))
		(define (push value) (set! s (cons value s)))
		(define (pop)
			(if (null? s)
				(error "Pop from empty stack")
				(let ((value (car s))) (set! s (cdr s)) value)
			)
		)
		(define (init) (set! s '()) 'done)
		(define (dispatch message)
			(cond 
				((eq? message 'push) push)
				((eq? message 'pop) (pop))
				((eq? message 'initialize) (init))
				(else (error "Unknown request -- STACK" message))
			)
		)
		dispatch
	)
)
(define (pop stack) (stack 'pop))
(define (push stack value) ((stack 'push) value))

(define (make-new-machine)
	(let
		(
			(pc (make-register 'pc))
			(flag (make-register 'flag))
			(stack (make-stack))
			(the-instruction-sequence '())
		)
		(let
			(
				(the-ops (list (list 'initialize-stack (lambda () (stack 'initialize)))))
				(register-table (list (list 'pc pc) (list 'flag flag)))
			)
			(define (allocate-register name)
				(if (assoc name register-table)
					(error "Multiply defined register" name)
					;ex 5.11(c)
					;(set! register-table (cons (list name (make-register name)) register-table))
					(set! register-table (cons (list name (make-stacked-register name)) register-table))
				)
			)
			(define (lookup-register name)
				(let ((val (assoc name register-table)))
					(if val
						(cadr val)
						(error "Register not found:" name)
					)
				)
			)
			(define (execute)
				(let ((insts (get-contents pc)))
					(if (null? insts)
						'done
						(begin
							((instruction-execution-proc (car insts)))
							(execute)
						)
					)
				)
			)
			; ex 5.11(c)
			(define (get-stack register)
				;stack
				(register 'stack)
			)
			(define (dispatch message)
				(cond
					((eq? message 'start)
						(set-contents! pc the-instruction-sequence)
						(execute)
					)
					((eq? message 'install-instruction-sequence)
						(lambda (insts) (set! the-instruction-sequence insts))
					)
					((eq? message 'allocate-register) allocate-register)
					((eq? message 'get-register) lookup-register)
					((eq? message 'install-operations)
						(lambda (ops) (set! the-ops (append the-ops ops)))
					)
					((eq? message 'stack) stack)
					((eq? message 'get-stack) get-stack)
					((eq? message 'operations) the-ops)
					(else (error "Unknown request -- MACHINE" message))
				)
			)
			dispatch
		)
	)
)

(define (start machine) (machine 'start))
(define (get-register-contents machine register-name) (get-contents (get-register machine register-name)))
(define (set-register-contents! machine register-name value)
	(set-contents! (get-register machine register-name) value)
	'done
)

(define (get-register machine register-name)
	((machine 'get-register) register-name))
(define (get-stack machine register)
	((machine 'get-stack) register)
)


(define (assemble controller-text machine)
	(extract-labels controller-text
		(lambda (insts labels)
			(update-insts! insts labels machine)
			insts
		)
	)
)
(define (extract-labels text receive)
	(if (null? text)
		(receive '() '())
		(extract-labels (cdr text)
			(lambda (insts labels)
				(let ((next-inst (car text)))
					(if (symbol? next-inst)
						; ex 5.8
						(let ((lbl (assoc next-inst labels)))
							(if lbl
								(error "Multiply defined label -- ASSEMBLE" lbl)
								(receive insts
									(cons (make-label-entry next-inst insts) labels)
								)
							)
						)
						(receive (cons (make-instruction next-inst) insts) labels)
					)
				)
			)
		)
	)
)
(define (update-insts! insts labels machine)
	(let ((pc (get-register machine 'pc))
		(flag (get-register machine 'flag))
		(stack (machine 'stack))
		(ops (machine 'operations)))
			(for-each
				(lambda (inst)
					(set-instruction-execution-proc! inst
						(make-execution-procedure (instruction-text inst) labels machine
							pc flag stack ops)
					)
				) 
				insts
			)
	)
)
(define (make-instruction text) (cons text '()))
(define (instruction-text inst) (car inst))
(define (instruction-execution-proc inst) (cdr inst))
(define (set-instruction-execution-proc! inst proc) (set-cdr! inst proc))

(define (make-label-entry label-name insts) (cons label-name insts))
(define (lookup-label labels label-name)
	(let ((val (assoc label-name labels)))
		(if val
			(cdr val)
			(error "Undefined label -- ASSEMBLE" label-name)
		)
	)
)

(define (make-execution-procedure inst labels machine
		pc flag stack ops)
	(cond
		((eq? (car inst) 'assign)
			(make-assign inst machine labels ops pc))
		((eq? (car inst) 'test)
			(make-test inst machine labels ops flag pc))
		((eq? (car inst) 'branch)
			(make-branch inst machine labels flag pc))
		((eq? (car inst) 'goto)
			(make-goto inst machine labels pc))
		((eq? (car inst) 'save)
			(make-save inst machine stack pc))
		((eq? (car inst) 'restore)
			(make-restore inst machine stack pc))
		((eq? (car inst) 'perform)
			(make-perform inst machine labels ops pc))
		(else (error "Unknown instruction type -- ASSEMBLE" inst))
	)
)

(define (make-assign inst machine labels operations pc)
	(let (	(target (get-register machine (assign-reg-name inst)))
		(value-exp (assign-value-exp inst)))
			(let 	((value-proc
					(if (operation-exp? value-exp)
						(make-operation-exp value-exp machine labels operations)
						(make-primitive-exp (car value-exp) machine labels)
					)
				)
				)
				;(display value-proc) (newline)
				(lambda ()	; execution procedure for assign
					(set-contents! target (value-proc))
					(advance-pc pc)
				)
			)
	)
)
(define (assign-reg-name assign-instruction) (cadr assign-instruction))
(define (assign-value-exp assign-instruction) (cddr assign-instruction))
(define (advance-pc pc)
	;(display (cadr (get-contents pc))) (newline)
	(set-contents! pc (cdr (get-contents pc))))

(define (make-test inst machine labels operations flag pc)
	(let ((condition (test-condition inst)))
		(if (operation-exp? condition)
			(let ((condition-proc (make-operation-exp condition machine labels operations)))
				(lambda ()
					(set-contents! flag (condition-proc))
					(advance-pc pc)
				)
			)
		)
	)
)
(define (test-condition test-instruction) (cdr test-instruction))
(define (make-branch inst machine labels flag pc)
	(let ((dest (branch-dest inst)))
		(if (label-exp? dest)
			(let ((insts (lookup-label labels (label-exp-label dest))))
				(lambda ()
					(if (get-contents flag)
						(set-contents! pc insts)
						(advance-pc pc)
					)
				)
			)
			(error "Bad BRANCH instruction -- ASSEMBLE" inst)
		)
	)
)
(define (branch-dest branch-instruction) (cadr branch-instruction))

(define (make-goto inst machine labels pc)
	(let ((dest (goto-dest inst)))
		(cond
			((label-exp? dest)
				(let ((insts (lookup-label labels (label-exp-label dest))))
					(lambda () (set-contents! pc insts))
				))
			((register-exp? dest)
				(let ((reg (get-register machine (register-exp-reg dest))))
					(lambda () (set-contents! pc (get-contents reg)))
				))
			(else (error "Bad GOTO instruction -- ASSEMBLE" inst))
		)
	)
)
(define (goto-dest goto-instruction) (cadr goto-instruction))
; ex 5.11(a) 
(define (make-save inst machine stack pc)
	(let ((reg (get-register machine (stack-inst-reg-name inst))))
		(lambda ()
			(push stack (get-contents reg))
			(advance-pc pc)
		)
	)
)
(define (make-restore inst machine stack pc)
	(let ((reg (get-register machine (stack-inst-reg-name inst))))
		(lambda ()
			(set-contents! reg (pop stack))
			(advance-pc pc)
		)
	)
)
; ex 5.11(b)
(define (make-save inst machine stack pc)
	(let ((reg (get-register machine (stack-inst-reg-name inst))))
		(lambda ()
			(push stack (cons (stack-inst-reg-name inst) (get-contents reg) ))
			(advance-pc pc)
		)
	)
)
(define (make-restore inst machine stack pc)
	(let ((reg (get-register machine (stack-inst-reg-name inst))))
		(lambda ()
			(define val (pop stack))
			(if (equal? (car val) (stack-inst-reg-name inst))
				(begin 
					(set-contents! reg (cadr val))
					(advance-pc pc)
				)
				(error (string "Restore from register " (car val) " into different register " (stack-inst-reg-name inst) " -- ASSEMBLE"))
			)
		)
	)
)
; ex 5.11(c)
(define (make-save inst machine stack pc)
	(let ((reg (get-register machine (stack-inst-reg-name inst))))
		(lambda ()
			(push (get-stack machine reg) (get-contents reg))
			(advance-pc pc)
		)
	)
)
(define (make-restore inst machine stack pc)
	(let ((reg (get-register machine (stack-inst-reg-name inst))))
		(lambda ()
			(set-contents! reg (pop (get-stack machine reg)))
			(advance-pc pc)
		)
	)
)
(define (stack-inst-reg-name stack-instruction) (cadr stack-instruction))

(define (make-perform inst machine labels operations pc)
	(let ((action (perform-action inst)))
		(if (operation-exp? action)
			(let ((action-proc (make-operation-exp action machine labels operations)))
				(lambda ()
					(action-proc)
					(advance-pc pc)
				)
			)
			(error "Bad PERFORM instruction -- ASSEMBLE" inst)
		)
	)
)
(define (perform-action inst) (cdr inst))

(define (make-primitive-exp exp machine labels)
	(cond
		((constant-exp? exp)
			(let ((c (constant-exp-value exp)))
				(lambda () c)
			))
		((label-exp? exp)
			(let ((insts (lookup-label labels (label-exp-label exp))))
				(lambda () insts)
			))
		((register-exp? exp)
			(let ((r (get-register machine (register-exp-reg exp))))
				(lambda () (get-contents r))
			))
		(else (error "Unknown expression type -- ASSEMBLE" exp))
	)
)

(define (register-exp? exp) (tagged-list? exp 'reg))
(define (register-exp-reg exp) (cadr exp))
(define (constant-exp? exp) (tagged-list? exp 'const))
(define (constant-exp-value exp) (cadr exp))
(define (label-exp? exp) (tagged-list? exp 'label))
(define (label-exp-label exp) (cadr exp))

;(define (make-operation-exp exp machine labels operations)
;	(let 	(
;			(op (lookup-prim (operation-exp-op exp) operations))
;			(aprocs (map 
;					(lambda (e) (make-primitive-exp e machine labels))
;					(operation-exp-operands exp)))
;		)
;			(lambda ()
;				(apply op (map (lambda (p) (p)) aprocs))
;			)
;	)
;)
; ex 5.9
(define (make-operation-exp exp machine labels operations)
	(if (fold-right (lambda (e rest)
				(and (or (constant-exp? e) (register-exp? e)) rest)) #t
			(operation-exp-operands exp))
		(let 	(
				(op (lookup-prim (operation-exp-op exp) operations))
				(aprocs (map 
						(lambda (e) (make-primitive-exp e machine labels))
						(operation-exp-operands exp)))
			)
				(lambda ()
					(apply op (map (lambda (p) (p)) aprocs))
				)
		)
		(error "Operations can only be used with registers and constants -- ASSEMBLE")
	)
)
(define (operation-exp? exp) (tagged-list? (car exp) 'op))
(define (operation-exp-op operation-exp) (cadr (car operation-exp)))
(define (operation-exp-operands operation-exp) (cdr operation-exp))

(define (lookup-prim symbol operations)
	(let ((val (assoc symbol operations)))
		(if val
			(cadr val)
			(error "Unknown operation -- ASSEMBLE" symbol)
		)
	)
)
